# Toy Java Virtual Machine

This project is an educational implementation of a Java Virtual Machine following
the [Java Virtual Machine Specification](https://docs.oracle.com/javase/specs/jvms/se25/html/). It aims to provide a
simple but functional runtime for executing Java bytecode. I'm targeting fully featured Java 25 support.

## Status

This project is in early development. Hello World works!

**See [docs/STATUS.md](docs/STATUS.md) for detailed implementation status.**

### Current Highlights

- ~148/200 bytecode opcodes implemented
- Integer/long/byte/short/char arithmetic with full tests
- Arrays (primitive + object) with tests
- Exception handling (try-catch-finally, stack traces) with tests
- Basic class loading from JImage and classpath

### Known Limitations

- `invokedynamic` not implemented (blocks lambdas, modern string concat)
- `checkcast` is a stub (always passes)
- Module system not implemented (initPhase2 skipped)
- Single-threaded only (monitors are no-op)
- No garbage collection

## Project Structure

This workspace consists of several crates (to be split into separate repositories eventually):

- **jclass** - Library that parses and maps the binary representation of `.class` files to Rust structures
- **common** - Utility library with shared functionality used across the workspace
- **javap** - Binary tool similar to `javap -v -p` for inspecting class files
- **runtime** - Library implementing the virtual machine that executes Java bytecode
- **vm** - Binary application that launches the runtime
- **jasm** - Binary and then library for assembling Java bytecode from a human-readable format (similar to `jasmin`)

## AI Assistant Infrastructure (OpenCode & OpenSpec)

This project uses OpenCode and OpenSpec to enable AI-assisted development. Important context:

1. **Primary Goal**: The main purpose of this project is to learn about Java and the JVM. AI agents will only be used to
   generate tests, documentation, and perform cosmetic refactoringâ€”not to implement any core technical logic.
2. **Project Scope**: As a solo project, it may not evolve into a production-ready system. AI assistance helps with
   non-functional tasks that would otherwise require additional contributors.
3. **Skill Development**: Using these tools provides practical experience with AI-assisted development workflows.
4. **OpenSpec Structure**: OpenSpec doesn't handle nested openspec directories well (e.g., specs inside crate folders).
   Two solutions exist: symlinks or file duplication. I chose duplication because crates will eventually become separate
   repositories, making this a temporary arrangement.

## Documentation

### Implementation Details

TODO

### References

- [JVM Specification SE 25](https://docs.oracle.com/javase/specs/jvms/se25/html/)

### Launch CI locally

This project uses GitHub Actions for continuous integration. It is possible to run the CI pipeline locally
using [act](https://github.com/nektos/act.git)

When the act tool is installed, it is necessary to use the `large` image to have all dependencies available.

```bash
cat ~/.config/act/actrc
-P ubuntu-latest=catthehacker/ubuntu:full-latest
-P ubuntu-22.04=catthehacker/ubuntu:full-22.04
-P ubuntu-20.04=catthehacker/ubuntu:full-20.04
-P ubuntu-18.04=catthehacker/ubuntu:full-18.04
```

I use the default `large` image from act, which is called `catthehacker/ubuntu:full-latest`.

To launch the CI pipeline, in the project root execute:

```bash
act
```

# Test data

## Description

In my opinion the tests right now are poorly organized. I want to improve that in the future. But right now
it is really important to have at least something, because the project is evolving fast and I want to be sure
that I don't break anything.

## Contents

- `jasm`: In early development, aims to provide an assembler for Java bytecode similar to `jasmin`. Test data will
  include various assembly files to cover different Java features and edge cases. Especially useful for testing bytecode
  that can't be generated by standard Java compilers.
- `build.rs`: Each crate that requires Java test fixtures has a `build.rs` script that automatically compiles Java
  source files during the build process. This is integrated into Cargo's build system, so fixtures are prepared
  automatically when running `cargo build` or `cargo test`.
- `jclass` tests reads all `.class` complied from all classes from `fixtures.toml`, all classes used in `runtime`
  tests, and all classes from `vm/tests`. It checks that it is parsed correctly. Right now it uses both snapshots
  and compare against `javap -v -p` output. In the future I want to remove one of them, because testing the same thing
  twice looks redundant, on the one hand snapshots are more predictable, on the other hand comparing against `javap` is
  more sure that the parsing is correct.
- `jclass/fixtures.toml`: A configuration file defining test fixtures from java standard libraries. Used only by
  `jclass` to test parsing of real-world class files. There is an assertion somewhere in `runtime` crate, whenever
  a jdk class is loaded, it is checked if it is present in this file. This is to ensure that the class file is correctly
  parsed and mapped to Rust structures.
- `runtime/testdata`: A directory containing Java source files for runtime tests. Each subdirectory represents a test
  case. This layer should cover a wide range of Java features and edge cases, taking a snapshots of the vm state after
  execution, and checking the heap, string pool and the top of the frame stack.
- `vm/tests`: Integration tests for the `vm` binary. These tests execute the `vm` binary with various Java classes
  and check the output against expected results.

## Usage

Test fixtures are prepared automatically by the `build.rs` scripts during `cargo build` or `cargo test`. No manual
fixture preparation is needed. Each crate compiles its Java test files to its own `tests/testdata/compiled` directory.

## TODO:

- delete snapshots for custom cases without Main postfix
